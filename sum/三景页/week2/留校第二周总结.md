# 总结
## 进程控制
这周是留校的第二周，学习了**Linuxc**中的进程控制，了解进程与程序的区别，进程是动态的，而程是动态，进程是动态的程序而程序是一保存在硬盘上的可执行代码
。同时还了解了进程是进程是操作系统资源管理的最小单位。然后还知道了我们可以
使用ps或者pstree来查看当前系统中的进程。

### fork和vfork。
fork和vfork和以遇到的函数不同，他由两个返回值，父进程调用的返回值为子进程
的ID，子进程调用的返回值为0，创建失败则返回-1。

但是二者又有不同之处：

* fork出的子进程完全复制父进程的资源，得到的子进程独立与父进程，具有良好的并发性。
* vfork创建的子进程共享父进程的地址空间，也就是说子进程完全运行在父进程地址空间上，子进程对该地址空间的任何数据修改同样为父进程所。
* 使用fork创建一个子进程，哪个进程运行取决于调度算法。而vfork保证子进程运行，知道子进程调用exec或exit后，父进程才调度运行。

关于fork和vfork还有一些坑点。如：当我们使用vfork务必调用exec或exit结进程
否则会发生一未知的错误，造成父进程出现错误。
因为父子进程共用一段地址空间，若不调用exic或exit，在子进程运行完会释放掉它所在的空间。参考进程的内存映像应该会更直观。
![内存映像图](http://img.blog.csdn.net/20160608131130199)
## shell
自己在写shell之前对管道了，重定向了等等都是似懂非懂，通过写shell的这个锻炼，自己对这些概念也更加深刻了。另外，shell当中关于参数的处理和逻辑关系方面的处理，自己作的实在时不怎么样。功能尽管都实现了，但是还是存在一些BUG以及自己难以处理的命令。不得不说自的功力还是很浅薄。
## 讲座
### 排序
学长给讲了很多的排序算法，以及对应算法的优化，自己也时受益匪浅。
冒泡的优化：可以在一遍历中同时找出最小的和最大的，然后分别放到数组两侧。（鸡尾酒排序）
快排的优化（三路快排）：在二路快排的基础上增加一路用来放相同的元素，减少不必要的交换次数。
归并排序：分而治之的思想，可以不用一次性把数据全部读入。仅需小部分逐渐拼凑，最后便可得到正确结。多用于较大数据的排序。
堆排序：主要麻烦在建堆上。建堆分为大根堆和小根堆。根据降序和升序的不同建立不同的堆。

同时还了解了排序算法的稳定性：排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化。

#### qsort函数的使用方法:
void qsort( void *base, size_t num, size_t width, int (__cdecl *compare )

int compare (const void *elem1, const void *elem2 ) );
第一个参数 base 是需要排序的目标数组名（或者也可以理解成开始排序的地址，因为可以写&s[i]这样的表达式）

第二个参数 num 是参与排序的目标数组元素个数

第三个参数 width 是单个元素的大小.推荐使用sizeof(s[0]）这样的表达式

第四个参数 compare 着重说明

一级排序：
```c
int num[100];

int cmp ( const void *a , const void *b )

{

  return *(int *)a - *(int *)b;  //升序排序

//return *(int *)b - *(int *)a; //降序排序
}
```
看了一些介cmp函数的博客一脸蒙蔽，自尝试只需要更改调换return中a,b的位置就可以实现升序和序的切换。
二级排序：
```c
五、对结构体二级排序

struct In

{

int x;   //可以比喻成：失败次数

int y;   //可以比喻成：成功次数

}s[100];

 

//按照x从小到大排序，当x相等时按照y从大到小排序。 你可以想象成：失败是主要因素的一个问题，先比较 失败次数少，失败次数相同 再看 成功次数多。

 

int cmp( const void *a , const void *b )

{

struct In *c = (In *)a;

struct In *d = (In *)b;

if(c->x != d->x) return c->x - d->x;

else return d->y - c->y;

}

qsort(s,100,sizeof(s[0]),cmp);

```
## 二叉树
在这周的二叉树讲解中自己了解了二叉树的创建，以前序，中序，后序遍历，并且根据之前学习的栈实二叉树的非递归前序遍历。
后来又讲解了赫夫曼编码，以及了解赫夫编码之所以能达到压缩作用的原因。同时在讨论时又有学长提出了静态链表的概念，即使用结构体，结构体中当前节点的值，当前节点父节点，左右子节点的下标，通过一些列的操作一个结构数组构建成链表。
同时发现自虽然先前学习过这方面的内容，但自己在而二叉树的非递归后序遍历
和二叉树的恢复方面还是存在问题，后面有机会应该查漏补缺。
## 进程
### 并发和并行
康康学长在进程讲开始前问过并行和并发的区别，这里我说说我理解的
![并发并行](https://pic4.zhimg.com/v2-674f0d37fca4fac1bd2df28a2b78e633_r.jpg)
并发是两个队列交替使用一台咖啡机，并行是两个队列同时使用两台咖啡机
并发的关键是你有处理多个任务的能力，不一定要同时。
并行的关键是你有同时处理多个任务的能力。
所以我认为它们最关键的点就是：是否是『同时』
### 进程池
在讲座中楚东方学长提到进程池，下来百度了一下，先看看度娘怎么说：进程池是**资源进程**、**管理进程**组成的技术的应用。

当时感觉讲座里面主要体现了资源进程，即预先创建好的空闲进程，管理进程会把工作分发到空闲进程来处理。
在管理进程这方面提的不是很多，管理进程负责创建资源进程，把工作交给空闲
资源进程处理，回收已经处理完工作的资源进程
然后有人问到如何知道进程池要未一个程序预留多少空闲进程：管理进程跟资源进程
间通过IPC，信号，信号量，消息队列，管道等进行交互。然后通过交互得到的
反馈来为资源分配空闲进程
